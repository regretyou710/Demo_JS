<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>構造函數修改</title>
    <script>
        /*
         創建一個Person構造函數
         - 在Person構造函數中，為每一個對象都添加了一個sayName方法，而該方法是在構造函數內部創建的
           ，也就是構造函數每執行一次就會創建一個新的sayName方法。所有實例的syaName方法都是唯一的。
           這樣就導致了構造函數執行一次就會創建一次新的方法，執行10000次就會創建10000個新的方法，而
           10000個方法都是一模一樣的，這是完全沒有必要，可以讓所有的對象都共享同一個方法。
        */

        function Person(name, age, gender) {
            this.name = name;
            this.age = age;
            this.gender = gender;
            // this.sayName = function () {
            //     alert(this.name);
            // };

            this.sayName = fun;
        }
        //將sayName方法在全局作用域中定義()，可以保證所有Person對象中的sayName方法都是同一個
        function fun() {
            alert(this.name);
        };

        var p1 = new Person('Eason', 34, '男');
        var p2 = new Person('Judy', 33, '女');
        p1.sayName();
        p2.sayName();

        //函數作用域中定義sayName方法，判斷p1,p2中的sayName方法是否一樣
        //console.log(p1.sayName == p2.sayName);// false，因為兩者方法(對象)記憶體中地址不同

        //全局作用域中定義sayName方法，判斷p1,p2中的sayName方法是否一樣
        console.log(p1.sayName == p2.sayName);// true，window對象中添加fun方法，只有一個對象
    </script>
</head>

<body>

</body>

</html>